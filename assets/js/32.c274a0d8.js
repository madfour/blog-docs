(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{481:function(v,_,e){"use strict";e.r(_);var o=e(27),t=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[v._v("整个在浏览器的渲染过程中（页面初始化，用户行为改变界面样式，动画改变界面样式等）,回流和重绘 都会大大影响"),e("code",[v._v("web")]),v._v("性能，尤其是手机页面。因此我们在页面设计的时候要尽量减少 reflow 和 repaint。")]),v._v(" "),e("h2",{attrs:{id:"回流-reflow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回流-reflow"}},[v._v("#")]),v._v(" 回流 reflow")]),v._v(" "),e("p",[v._v("当构造渲染树("),e("code",[v._v("render tree")]),v._v(")中部分或全部节点, 因元素的尺寸、布局、隐藏等改变而需要重新构建，计算它们在设备视口 (viewport) 内的确切位置和大小，浏览器重新渲染的过程称为 回流。")]),v._v(" "),e("h2",{attrs:{id:"重绘-repaint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘-repaint"}},[v._v("#")]),v._v(" 重绘 repaint")]),v._v(" "),e("p",[v._v("当页面中元素样式（例如："),e("code",[v._v("color")]),v._v("、"),e("code",[v._v("background-color")]),v._v("等）的改变并不影响它周围或内部布局（尺寸、大小等）时，浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。")]),v._v(" "),e("h2",{attrs:{id:"何时发生回流重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#何时发生回流重绘"}},[v._v("#")]),v._v(" 何时发生回流重绘")]),v._v(" "),e("p",[v._v("当"),e("code",[v._v("Render Tree")]),v._v("中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器将重新渲染部分或全部文档，这时发生的就是回流。")]),v._v(" "),e("p",[v._v("会导致回流的操作：")]),v._v(" "),e("ul",[e("li",[v._v("页面首次渲染")]),v._v(" "),e("li",[v._v("浏览器窗口大小发生改变")]),v._v(" "),e("li",[v._v("元素尺寸或位置发生改变（包括外边距、内边框、边框大小、高度和宽度等）")]),v._v(" "),e("li",[v._v("元素内容变化（文字数量或图片大小，比如用户在 input 框中输入文字等等）")]),v._v(" "),e("li",[v._v("元素字体大小变化")]),v._v(" "),e("li",[v._v("添加或者删除"),e("strong",[v._v("可见")]),v._v("的"),e("code",[v._v("DOM")]),v._v("元素")]),v._v(" "),e("li",[v._v("激活"),e("code",[v._v("CSS")]),v._v("伪类（例如："),e("code",[v._v(":hover")]),v._v("）")]),v._v(" "),e("li",[v._v("查询某些属性或调用某些方法")])]),v._v(" "),e("p",[v._v("当页面中元素样式的改变并不影响它在文档流中的位置时（例如："),e("code",[v._v("color")]),v._v("、"),e("code",[v._v("background-color")]),v._v("、"),e("code",[v._v("visibility")]),v._v("等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。")]),v._v(" "),e("p",[e("strong",[v._v("回流一定会触发重绘，而重绘不一定会回流")])]),v._v(" "),e("h2",{attrs:{id:"性能与优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能与优化"}},[v._v("#")]),v._v(" 性能与优化")]),v._v(" "),e("p",[v._v("现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即 16.6ms）才会清空队列。")]),v._v(" "),e("p",[v._v("但当你"),e("strong",[v._v("获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值")]),v._v("。")]),v._v(" "),e("p",[v._v("比如当你访问以下属性或者使用以下方法：")]),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("offsetTop、offsetLeft、offsetWidth、offsetHeight")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("scrollTop、scrollLeft、scrollWidth、scrollHeight")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("clientTop、clientLeft、clientWidth、clientHeight")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("getComputedStyle()")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("getBoundingClientRect")])])])]),v._v(" "),e("h2",{attrs:{id:"手动优化-减少重绘与回流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#手动优化-减少重绘与回流"}},[v._v("#")]),v._v(" 手动优化，减少重绘与回流")]),v._v(" "),e("ul",[e("li",[e("p",[e("strong",[v._v("使用 "),e("code",[v._v("transform")]),v._v(" 替代 "),e("code",[v._v("top")])])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("使用 "),e("code",[v._v("visibility")]),v._v(" 替换 "),e("code",[v._v("display: none")])]),v._v(" ，因为前者只会引起重绘，后者会引发回流（改变了布局")])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("避免使用"),e("code",[v._v("table")]),v._v("布局")]),v._v("，可能很小的一个小改动会造成整个 "),e("code",[v._v("table")]),v._v(" 的重新布局。")])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("尽可能在"),e("code",[v._v("DOM")]),v._v("树的最末端改变"),e("code",[v._v("class")])]),v._v("，回流是不可避免的，但可以减少其影响。尽可能在 DOM 树的最末端改变 class，可以限制了回流的范围，使其影响尽可能少的节点。")])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("避免频繁操作样式")]),v._v("，最好一次性重写"),e("code",[v._v("style")]),v._v("属性，或者将样式列表定义为"),e("code",[v._v("class")]),v._v("并通过更改元素"),e("code",[v._v("class")]),v._v("属性来应用样式。")]),v._v(" "),e("blockquote",[e("p",[v._v("通过 style 属性设置样式导致回流。避免设置多级内联样式，因为每个都会造成回流，样式应该合并在一个外部类，这样当该元素的 class 属性可被操控时仅会产生一个 reflow。")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("避免频繁操作"),e("code",[v._v("DOM")])]),v._v("，创建一个"),e("code",[v._v("documentFragment")]),v._v("，在它上面应用所有"),e("code",[v._v("DOM操作")]),v._v("，最后再把它添加到文档中。")]),v._v(" "),e("blockquote",[e("p",[v._v("DocumentFragment 节点不属于文档树，在把它插入文档节点之前，随便给他增删节点都不会引起回流。")]),v._v(" "),e("p",[v._v("使用 cloneNode 和 replaceChild 有类似的效果")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("将动画效果应用到"),e("code",[v._v("position")]),v._v("属性为"),e("code",[v._v("absolute")]),v._v("或"),e("code",[v._v("fixed")]),v._v("的元素上")]),v._v("，避免影响其他元素的布局，")]),v._v(" "),e("blockquote",[e("p",[v._v("对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("避免使用"),e("code",[v._v("CSS")]),v._v("表达式")]),v._v("，（例如："),e("code",[v._v("calc()")]),v._v("）可能会引发回流。")])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("将频繁重绘或者回流的节点设置为图层")]),v._v("，图层能够阻止该节点的渲染行为影响别的节点，例如"),e("code",[v._v("will-change")]),v._v("、"),e("code",[v._v("video")]),v._v("、"),e("code",[v._v("iframe")]),v._v("等标签，浏览器会自动将该节点变为图层。")])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("CSS3 硬件加速（GPU 加速）")])]),v._v(" "),e("blockquote",[e("p",[v._v("**使用 css3 硬件加速，可以让"),e("code",[v._v("transform")]),v._v("、"),e("code",[v._v("opacity")]),v._v("、"),e("code",[v._v("filters")]),v._v("这些动画不会引起回流重绘 **。但是对于动画的其它属性，比如"),e("code",[v._v("background-color")]),v._v("这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。")])])]),v._v(" "),e("li",[e("p",[v._v("避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。")])])]),v._v(" "),e("h2",{attrs:{id:"扩展-浏览器渲染过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#扩展-浏览器渲染过程"}},[v._v("#")]),v._v(" 扩展：浏览器渲染过程")]),v._v(" "),e("p",[v._v("页面加载时，浏览器的渲染过程")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/211a4cf8f33844acb858e264d6695a51~tplv-k3u1fbpfcp-zoom-1.image",alt:"img"}})]),v._v(" "),e("ul",[e("li",[v._v("解析"),e("code",[v._v("HTML")]),v._v("，生成"),e("code",[v._v("DOM")]),v._v("树，解析"),e("code",[v._v("CSS")]),v._v("，生成"),e("code",[v._v("CSSOM")]),v._v("树；两树结合，生成渲染树"),e("code",[v._v("(Render Tree)")]),v._v("。")]),v._v(" "),e("li",[e("code",[v._v("Layout(回流)")]),v._v(":根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）。")]),v._v(" "),e("li",[e("code",[v._v("Painting(重绘)")]),v._v(":根据渲染树以及回流得到的几何信息，得到节点的绝对像素。")]),v._v(" "),e("li",[e("code",[v._v("Display")]),v._v(": 将像素发送给"),e("code",[v._v("GPU")]),v._v("，展示在页面上（这一步其实还有很多内容，比如会在 GPU 将多个合成层合并为同一个层，并展示在页面中。而 css3 硬件加速的原理则是新建合成层）")])]),v._v(" "),e("p",[v._v("为了构建渲染树，浏览器主要完成了以下工作：")]),v._v(" "),e("ul",[e("li",[v._v("从"),e("code",[v._v("DOM")]),v._v("树的根节点开始遍历每个可见节点。")]),v._v(" "),e("li",[v._v("对于每个可见的节点，找到"),e("code",[v._v("CSSOM")]),v._v("树中对应的规则，并应用它们。")]),v._v(" "),e("li",[v._v("根据每个可见节点以及其对应的样式，组合生成渲染树。")])]),v._v(" "),e("p",[v._v("渲染树中只会包含可见节点。不可见节点包括：")]),v._v(" "),e("ul",[e("li",[v._v("一些不会渲染输出的节点，比如"),e("code",[v._v("script、meta、link")]),v._v("等。")]),v._v(" "),e("li",[v._v("一些通过"),e("code",[v._v("css")]),v._v("进行隐藏的节点。如"),e("code",[v._v("display:none")]),v._v("。")])]),v._v(" "),e("blockquote",[e("p",[v._v("注意，利用"),e("code",[v._v("visibility")]),v._v("和"),e("code",[v._v("opacity")]),v._v("隐藏的节点，还是会显示在渲染树上的。")])]),v._v(" "),e("blockquote",[e("p",[v._v("由于浏览器使用流式布局，对"),e("code",[v._v("Render Tree")]),v._v("的计算通常只需要遍历一次就可以完成，但 table 及其内部元素除外，他们可能需要多次计算")])])])}),[],!1,null,null,null);_.default=t.exports}}]);