---
title: JS - call、apply和bind的区别
date: 2022-04-29 18:06:54
permalink: /js/ab2880/
categories:
  - JavaScript
tags:
  - JavaScript
---

## 概括
都是可以改变函数内`this`指向的方法。

- `call()`方法使用一个指定的`this`值和单独给出的**一个或多个参数**来调用一个函数;
  - 语法：`fn.call(thisArg, arg1, arg2, ...)`。

- `apply()`方法使用一个指定的`this`值和单独给出**一个或多个参数的数组**来调用一个函数;
  - 语法：`fn.apply(thisArg, [arg1,arg2,...])`。
  
- `bind()`方法创建一个新的函数，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用；
  - 语法：`fn.bind(thisArg[, arg1[, arg2[, ...]]])`。


## `call()、apply()`
> ·call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。　　

- 适用条件。`JavaScript` 中，某个函数的参数数量是不固定的，因此要说适用条件的话，
  - 当你的参数是明确知道数量时用 `call` 。
  - 而不确定的时候用 `apply`，然后把参数 `push` 进数组传递进去。当参数数量不确定时，函数内部也可以通过 `arguments` 这个伪数组来遍历所有的参数。

- 区别
`call、apply`的作用完全一样，唯一的区别就在于**传参的格式不一样**。
  - `call`方法接受的是**若干个参数的列表**（可以是数组或者类数组）；
  - `apply`方法接受的是一个**包含多个参数的数组**。


### 使用场景
一些常用用法示例：
- 1、**合并数组**
  ```js
  var ary1 = [10, 'str1', null, {obj:'111'}]
  var ary2 = ['str2', -100]

  // 相当于 ary1.push('str2', -100)
  Array.prototype.push.apply(ary1, ary2)
  // console.log(ary1) 的结果就是[10, 'str1', null, {obj:'111'}, 'str2', -100]
  ```

- 2、**获取数组中的最大值和最小值**
  ```js
  var numbers = [5, 458 , 120 , -215 ]; 
  var maxInNumbers = Math.max.apply(Math, numbers),   //458
      maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458
  ```
  `number` 本身没有 `max` 方法，但是 `Math` 有，我们就可以借助 `call` / `apply` 使用其方法。

- 3、**验证是否是数组**，(前提是 `toString()` 方法没有被重写过)
  ```js
  function isArray(obj){ 
    return Object.prototype.toString.call(obj) === '[object Array]' ;
  }

  isArray([1, 2, 3])  // true
  ```

- 4、**类（伪）数组使用数组方法**
  ```js
  var 
  var domNodes = Array.prototype.slice.call(document.getElementsByTagName("*"));
  ```
  Javascript中存在一种名为**伪数组**的对象结构。比较特别的是 `arguments` 对象，还有像调用 `getElementsByTagName` 、`document.childNodes` 之类的，它们返回 `NodeList` 对象都属于伪数组。不能应用 `Array` 下的 `push`、`pop` 等方法。

  但是我们能通过 `Array.prototype.slice.call` 转换为真正的数组的带有 `length` 属性的对象，这样 `domNodes` 就可以应用 `Array` 下的所有方法了。

  **类（伪）数组对象转数组**的其它方法
  ```js
  // 上面代码等同于:
  var arr = [].slice.call(arguments)
  // 例：[].slice.call(document.getElementsByTagName("*"))

  // ES6:
  let arr = Array.from(arguments)
  let arr = [...arguments]
  ```
  `Array.from()`可以将两类对象转为真正的数组：**类数组**对象和**可遍历**(iterable)对象（包括ES6新增的数据结构Set和Map）

- 5、**调用构造函数实现继承**
  ```js
  function Parent(){
    this.color = ['red', 'black']
  }
  function Child(){
    // 核心代码，继承自Parent
    Parent.call(this)
  }

  var child1 = new Child()
  child1.color.push('white')
  console.log(child1.color) // ['red', 'black', 'white']
  
  var child2 = new Child()
  console.log(child2.color) // ['red', 'black']
  ```
  **缺点：**只能继承父类的实例属性和方法，不能继承原型属性/方法；无法复用，每个子类都有父类实例函数的副本，影响性能。


### 模拟实现`call`
```js
// ES3写法
Function.prototype.setCall = function (context) {
  context = context ? Object(context) : window;   // 确定 this 指向
  context.fn = this;      // 将函数变成对象的内部属性

  // 参数的个数不确定，从 Arguments 对象中取值，因为arguments是类数组对象，所以可以用for循环
  var args = [];
  for (var i = 1, len = arguments.length; i < len; i++) {
    args.push('arguments[' + i + ']');
  }
  var result = eval('context.fn(' + args + ')');    // 将数组里的元素作为多个参数放进函数的形参里

  delete context.fn
  return result;
}

// ES6写法
Function.prototype.setCall = function (context) {
  context = context ? Object(context) : window;
  context.fn = this;

  let args = [...arguments].slice(1);
  let result = context.fn(...args);

  delete context.fn
  return result;
}
```
**测试**
```js
var val = 2
var obj = {
  val: 10
}
function bar(name, age){
  console.log('bar:', this.val)
  return {
    val: this.val,
    name: name,
    age: age
  }
}

bar.setCall(null) // bar: 2   this指向window
console.log(bar.setCall(obj, '111', 18))    // this指向obj
/*
* bar: 10
* {val: 10, name: '111', age: 18}
*/
```

### 模拟实现`apply`
```js
// ES3写法
Function.prototype.setApply = function(context, arr) {
  context = context ? Object(context) : window;
  context.fn = this;

  var result;
  // 判断是否存在第二个参数
  if (!arr) {
    result = context.fn();
  } else {
    var args = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      args.push('arr[' + i + ']');
    }
    result = eval('context.fn(' + args + ')');
  }

  delete context.fn
  return result;
}


// ES6写法
Function.prototype.setApply = function (context, arr) {
  context = context ? Object(context) : window; 
  context.fn = this;

  let result;
  if (!arr) {
    result = context.fn();
  } else {
    result = context.fn(...arr);
  }

  delete context.fn
  return result;
}
```

### 重要链接
::: tip 模拟实现的详情步骤见：
[JavaScript深入之call和apply的模拟实现](https://github.com/mqyqingfeng/Blog/issues/11)
:::


## `bind()`

