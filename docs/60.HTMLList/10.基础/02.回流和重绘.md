---
title: 介绍下重绘和回流，以及如优化?
date: 2020-09-06 20:34:56
permalink: /HTML/685788/
categories:
  - 前端
  - HTML
  - CSS
tags:
  - HTML
  - CSS
author:
---

整个在浏览器的渲染过程中（页面初始化，用户行为改变界面样式，动画改变界面样式等）,回流和重绘 都会大大影响`web`性能，尤其是手机页面。因此我们在页面设计的时候要尽量减少 reflow 和 repaint。

<!-- more -->

## 回流 reflow

当构造渲染树(`render tree`)中部分或全部节点, 因元素的尺寸、布局、隐藏等改变而需要重新构建，计算它们在设备视口 (viewport) 内的确切位置和大小，浏览器重新渲染的过程称为 回流。

## 重绘 repaint

当页面中元素样式（例如：`color`、`background-color`等）的改变并不影响它周围或内部布局（尺寸、大小等）时，浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

## 何时发生回流重绘

当`Render Tree`中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器将重新渲染部分或全部文档，这时发生的就是回流。

会导致回流的操作：

- 页面首次渲染
- 浏览器窗口大小发生改变
- 元素尺寸或位置发生改变（包括外边距、内边框、边框大小、高度和宽度等）
- 元素内容变化（文字数量或图片大小，比如用户在 input 框中输入文字等等）
- 元素字体大小变化
- 添加或者删除**可见**的`DOM`元素
- 激活`CSS`伪类（例如：`:hover`）
- 查询某些属性或调用某些方法

当页面中元素样式的改变并不影响它在文档流中的位置时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

**回流一定会触发重绘，而重绘不一定会回流**

## 性能与优化

现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即 16.6ms）才会清空队列。

但当你**获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值**。

比如当你访问以下属性或者使用以下方法：

- `offsetTop、offsetLeft、offsetWidth、offsetHeight`

- `scrollTop、scrollLeft、scrollWidth、scrollHeight`
- `clientTop、clientLeft、clientWidth、clientHeight`
- `getComputedStyle()`
- `getBoundingClientRect`

## 手动优化，减少重绘与回流

- **使用 `transform` 替代 `top`**

- **使用 `visibility` 替换 `display: none`** ，因为前者只会引起重绘，后者会引发回流（改变了布局

- **避免使用`table`布局**，可能很小的一个小改动会造成整个 `table` 的重新布局。

- **尽可能在`DOM`树的最末端改变`class`**，回流是不可避免的，但可以减少其影响。尽可能在 DOM 树的最末端改变 class，可以限制了回流的范围，使其影响尽可能少的节点。

- **避免频繁操作样式**，最好一次性重写`style`属性，或者将样式列表定义为`class`并通过更改元素`class`属性来应用样式。

  > 通过 style 属性设置样式导致回流。避免设置多级内联样式，因为每个都会造成回流，样式应该合并在一个外部类，这样当该元素的 class 属性可被操控时仅会产生一个 reflow。

- **避免频繁操作`DOM`**，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。

  > DocumentFragment 节点不属于文档树，在把它插入文档节点之前，随便给他增删节点都不会引起回流。
  >
  > 使用 cloneNode 和 replaceChild 有类似的效果

- **将动画效果应用到`position`属性为`absolute`或`fixed`的元素上**，避免影响其他元素的布局，

  > 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

- **避免使用`CSS`表达式**，（例如：`calc()`）可能会引发回流。

- **将频繁重绘或者回流的节点设置为图层**，图层能够阻止该节点的渲染行为影响别的节点，例如`will-change`、`video`、`iframe`等标签，浏览器会自动将该节点变为图层。

- **CSS3 硬件加速（GPU 加速）**

  > **使用 css3 硬件加速，可以让`transform`、`opacity`、`filters`这些动画不会引起回流重绘 **。但是对于动画的其它属性，比如`background-color`这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。

## 扩展：浏览器渲染过程

页面加载时，浏览器的渲染过程

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/211a4cf8f33844acb858e264d6695a51~tplv-k3u1fbpfcp-zoom-1.image)

- 解析`HTML`，生成`DOM`树，解析`CSS`，生成`CSSOM`树；两树结合，生成渲染树`(Render Tree)`。
- `Layout(回流)`:根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）。
- `Painting(重绘)`:根据渲染树以及回流得到的几何信息，得到节点的绝对像素。
- `Display`: 将像素发送给`GPU`，展示在页面上（这一步其实还有很多内容，比如会在 GPU 将多个合成层合并为同一个层，并展示在页面中。而 css3 硬件加速的原理则是新建合成层）

为了构建渲染树，浏览器主要完成了以下工作：

- 从`DOM`树的根节点开始遍历每个可见节点。
- 对于每个可见的节点，找到`CSSOM`树中对应的规则，并应用它们。
- 根据每个可见节点以及其对应的样式，组合生成渲染树。

渲染树中只会包含可见节点。不可见节点包括：

- 一些不会渲染输出的节点，比如`script、meta、link`等。
- 一些通过`css`进行隐藏的节点。如`display:none`。

> 注意，利用`visibility`和`opacity`隐藏的节点，还是会显示在渲染树上的。

> 由于浏览器使用流式布局，对`Render Tree`的计算通常只需要遍历一次就可以完成，但 table 及其内部元素除外，他们可能需要多次计算
